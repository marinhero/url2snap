/*
** urlbox.go
** Author: Marin Alcaraz
** Mail   <marin.alcaraz@gmail.com>
 */

//Package urlbox manages the interaction with the urlbox.io API
package urlbox

import (
	"crypto/hmac"
	"crypto/sha1"
	"encoding/hex"
	"fmt"
	"io"
	"log"
	"net/http"
	"os"
)

//ShotData describes the struct that represents the data for a screenshot
type ShotData struct {
	URL    string
	Width  uint
	Height uint
}

//API_URL="https://api.urlbox.io/v1/$K/$T/png?$Q"

//BASICQS is the empty query string
const BASICQS = "url=%s&width=%d&height=%d"

//PREURL stands for preformated URL
const PREURL = "https://api.urlbox.io/v1/%s/%s/png?%s"

//APIKEY from urlbox available on your profile
const APIKEY = ""

//APISECRET from urlbox available on your profile
const APISECRET = ""

//Format describes the snapshot format
const FORMAT = ".png"

//GetFileName transforms a ShotData struct into the snapshot name
func GetFileName(data ShotData) (fileName string) {
	width := fmt.Sprint(data.Width)
	height := fmt.Sprint(data.Height)
	fileName = data.URL + width +
		"x" + height + FORMAT
	return
}

//GetScreenshot hits the urlbox API and returns the corresponding statusCode
func GetScreenshot(url string, fileName string) (statusCode string) {
	client := &http.Client{}
	resp, _ := client.Get(url)
	if resp.Status == "200 OK" {
		file, err := os.Create(fileName)
		if err != nil {
			log.Fatal("[!]GetScreenshot: ", err)
		}
		defer file.Close()
		defer resp.Body.Close()
		io.Copy(file, resp.Body)
	}
	statusCode = resp.Status
	return
}

//GenerateToken The token is generated by taking the HMAC SHA1 of
//the query string and signing it with your API Secret.
func GenerateToken(qs string) (token string) {
	key := []byte(APISECRET)
	h := hmac.New(sha1.New, key)
	h.Write([]byte(qs))
	token = hex.EncodeToString(h.Sum(nil))
	return
}

//CreateRequestString returns the requestString to retrieve a png image
func CreateRequestString(qs string) (requestString string) {
	token := GenerateToken(qs)
	requestString = fmt.Sprintf(PREURL, APIKEY, token, qs)
	return
}

//CreateShot wraps all. Given ShotData download Shot and return status
func CreateShot(newShotInfo ShotData) (status string) {
	if newShotInfo.URL != "" &&
		newShotInfo.Width > 0 &&
		newShotInfo.Height > 0 {
		queryString := fmt.Sprintf(BASICQS, newShotInfo.URL,
			newShotInfo.Width, newShotInfo.Height)
		requestString := CreateRequestString(queryString)
		width := fmt.Sprint(newShotInfo.Width)
		height := fmt.Sprint(newShotInfo.Height)
		fileName := newShotInfo.URL + width +
			"x" + height + FORMAT
		statusCode := GetScreenshot(requestString, fileName)
		if statusCode == "200 OK" {
			status = "OK"
			return
		}
	}
	status = "KO"
	return
}
